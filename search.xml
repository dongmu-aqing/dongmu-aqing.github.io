<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试题</title>
      <link href="/2022/11/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/11/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1，闭包是什么"><a href="#1，闭包是什么" class="headerlink" title="1，闭包是什么"></a>1，闭包是什么</h1><p><code>两个函数（a,b）嵌套，内层函数b 调用了外层函数a中声明的变量，就叫闭包</code></p><h1 id="2，数组中的forEach和map："><a href="#2，数组中的forEach和map：" class="headerlink" title="2，数组中的forEach和map："></a>2，数组中的forEach和map：</h1><h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p><code> 都是遍历数组每一项，都有三个参数，都不改变原数组</code></p><h2 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h2><p><code> forEach是将一个数组中的每一项作为回调函数来处理，</code><br><code> map则返回一个新数组，数组中的元素是原数组的方法处理后的值</code></p><h1 id="3，浅拷贝和深拷贝"><a href="#3，浅拷贝和深拷贝" class="headerlink" title="3，浅拷贝和深拷贝"></a>3，浅拷贝和深拷贝</h1><h2 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h2><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><p><code>拷贝值，原来的和拷贝的互不影响</code></p><h3 id="引用数据类型："><a href="#引用数据类型：" class="headerlink" title="引用数据类型："></a>引用数据类型：</h3><p><code>拷贝地址，一改变原来的和拷贝的都改变，可以用展开运算符进行浅拷贝</code></p><h2 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h2><h3 id="引用数据类型：-1"><a href="#引用数据类型：-1" class="headerlink" title="引用数据类型："></a>引用数据类型：</h3><p><code>内存中开辟新地址，堆中的内容完整拷贝一份到新地址中，修改一个另一个并不受影响</code><br><code>可以用递归的方式进行深拷贝</code></p><h1 id="4，防抖和节流"><a href="#4，防抖和节流" class="headerlink" title="4，防抖和节流"></a>4，防抖和节流</h1><h2 id="防抖："><a href="#防抖：" class="headerlink" title="防抖："></a>防抖：</h2><p><code>连续触发事件，但是在设定的一段时间内只执行最后一次函数</code><br><code>记忆核心：从 新 开始</code><br><code>应用场景：文本编辑器和搜索框</code><br><code>代码实现思路主要靠定时器</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">   <span class="keyword">let</span> tid=<span class="literal">null</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;获取要操作的元素&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tid!==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(tid)</span><br><span class="line">        &#125;</span><br><span class="line">        tid=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;防抖&#x27;</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="节流："><a href="#节流：" class="headerlink" title="节流："></a>节流：</h2><p><code>连续触发事件但是在设定的一段时间内只执行一次函数</code></p><h3 id="记忆核心：-不要打断我"><a href="#记忆核心：-不要打断我" class="headerlink" title="记忆核心： 不要打断我"></a>记忆核心： <code>不要打断我</code></h3><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p><code>1，高频事件：快速点击，鼠标滑动，resize事件，scroll事件</code><br><code>2，下拉加载</code><br><code>3，视频播放记录时间等</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 代码示例</span></span><br><span class="line">    <span class="keyword">let</span> tid=<span class="literal">null</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;获取要操作的元素&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tid!==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        tid=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;防抖&#x27;</span>);</span><br><span class="line">            tid=<span class="literal">null</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//开发一般用lodash库，利用里面的debounce（防抖）和throttle（节流）来做</span></span><br></pre></td></tr></table></figure><h1 id="5，原型和原型链"><a href="#5，原型和原型链" class="headerlink" title="5，原型和原型链"></a>5，原型和原型链</h1><h2 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h2><p><code>所有的引用类型都有一个__proto__属性，所有的函数都有一个prototype属性</code><br><code>所有引用类型的__proto__都指向它构造函数的prototype</code></p><h2 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h2><p><code>当访问一个对象的某个属性的时候，先在对象本身查找，</code><br><code>如果没有，就去他的__proto__属性上找</code><br><code>如果还没有，就去__proto__所指向的构造函数的prototype找</code><br><code>还没有就去Object上找，最顶为null，这样的一个链式结构，就叫做原型链</code></p><h1 id="6，thie指向问题"><a href="#6，thie指向问题" class="headerlink" title="6，thie指向问题"></a>6，thie指向问题</h1><p><code>函数调用指向window</code><br><code>方法调用指向对象</code><br><code>构造函数调用指向它的实例对象</code><br><code>箭头函数则看外层有没有函数，有的话和外层函数指向一样，没有指向window</code></p><h1 id="7，call，bind，apply"><a href="#7，call，bind，apply" class="headerlink" title="7，call，bind，apply"></a>7，call，bind，apply</h1><p><code>都是用来改变this指向</code><br><code>第一个参数都是this的新指向</code><br><code>第二个及之后的参数call和bind是直接传入函数值，apply第二个参数则是数组或伪数组</code><br><code>bind方法不会直接执行函数，其他两个会主动执行函数</code></p><h1 id="8，回流和重绘的说明"><a href="#8，回流和重绘的说明" class="headerlink" title="8，回流和重绘的说明"></a>8，回流和重绘的说明</h1><h2 id="回流"><a href="#回流" class="headerlink" title="回流:"></a>回流:</h2><p><code>访问页面的时候浏览器会解析HTML代码并构建DOM树，</code><br><code>然后根据DOM节点进行几何布局生成渲染树，渲染树构建完成后，页面根据DOM节点进行几何布局</code><br><code>渲染树也根据设置的样式渲染这些节点，在这过程中我们删除节点，修改一个元素的宽高，页面布局会发生变化，DOM树就会重新构建</code><br><code>渲染树和DOM树紧密相连，渲染树也会重新渲染，这个过程称为回流或自动重排</code></p><h2 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h2><p><code>由于节点的几何属性发生改变或者由样式发生改变而不影响布局的，叫做重绘</code><br><code>个人简单理解：页面布局发生变化，会引起回流，修改元素样式不改变布局，会引起重绘</code><br><code>注意： 回流一定触发重绘，重绘不一定触发回流</code></p><h1 id="9，new关键字做了哪些事"><a href="#9，new关键字做了哪些事" class="headerlink" title="9，new关键字做了哪些事"></a>9，new关键字做了哪些事</h1><p><code>1，new一个空对象</code><br><code>2，将函数的this指向这个空对象</code><br><code>3，为新创建的对象添加__proto__,指向构造函数的原型对象</code><br><code>4，如果函数返回对象，就把这个对象作为返回值，如果没有返回对象就返回this</code></p><h1 id="10，async和await的理解"><a href="#10，async和await的理解" class="headerlink" title="10，async和await的理解"></a>10，async和await的理解</h1><p><code>1，是异步代码的新方式</code><br><code>2，基于promise实现</code><br><code>3，使异步代码更像同步代码</code><br><code>4，await只能在async中使用，不能在普通函数中使用，成对出现</code><br><code>5，默认返回一个promise实例，不能改变</code><br><code>6，await下面的代码是异步，后面的代码是同步的</code></p><h1 id="11-如何理解promise？"><a href="#11-如何理解promise？" class="headerlink" title="11,如何理解promise？"></a>11,如何理解promise？</h1><p><code>1，异步编程的解决方案，用来解决回调地狱</code><br><code>2,有三种状态：pending（进行中），fufilled（已成功），rejected（已失败）</code><br><code>3，基本用法是new Promise（）传入一个函数，函数里面有两个参数，一个是resolve成功的回调，一个是reject失败的回调</code><br><code>new出来的有三个方法：参数都是一个数组</code><br><code>all:如果数组里面所有的promise都是resolve就进入then方法，有一个reject就进入catch</code><br><code>allSettled：在then方法中返回所有的promise数组结果，不管成功的还是失败的</code><br><code>rece：数组中的promise哪个先返回结果就使用哪个结果</code></p><h1 id="12-对作用域进行说明"><a href="#12-对作用域进行说明" class="headerlink" title="12,对作用域进行说明"></a>12,对作用域进行说明</h1><h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p><code>指变量的有效范围</code></p><h3 id="有三种作用域-分别是："><a href="#有三种作用域-分别是：" class="headerlink" title="有三种作用域 分别是："></a>有三种作用域 分别是：</h3><h2 id="全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到"><a href="#全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到" class="headerlink" title="全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到"></a>全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到</h2><h2 id="局部作用域（函数作用域）：-在函数内可以访问，函数外部无法访问"><a href="#局部作用域（函数作用域）：-在函数内可以访问，函数外部无法访问" class="headerlink" title="局部作用域（函数作用域）： 在函数内可以访问，函数外部无法访问"></a>局部作用域（函数作用域）： 在函数内可以访问，函数外部无法访问</h2><h2 id="块级作用域（es6新增）：-凡是代码块就可以划分变量的作用域"><a href="#块级作用域（es6新增）：-凡是代码块就可以划分变量的作用域" class="headerlink" title="块级作用域（es6新增）：  凡是代码块就可以划分变量的作用域"></a>块级作用域（es6新增）：  凡是代码块就可以划分变量的作用域</h2><h1 id="13，事件对象和事件委托"><a href="#13，事件对象和事件委托" class="headerlink" title="13，事件对象和事件委托"></a>13，事件对象和事件委托</h1><h2 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h2><p><code>一个函数或者方法都会带有一个事件对象参数</code><br><code>事件对象.target是获取最先触发的元素</code><br><code>事件对象有两种公共的方法：</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="title function_">preventDefault</span>() <span class="comment">//阻止默认行为</span></span><br><span class="line">e.<span class="title function_">stopPropagation</span>() <span class="comment">//阻止冒泡</span></span><br></pre></td></tr></table></figure><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><code>可以把事件处理器添加到一个上级元素上，避免把事件处理器添加到多个子元素上，提高性能</code><br><code>还可以预测未来，动态添加的元素仍然可以触发该事件</code><br><code>主要依靠的就是事件冒泡，也就是当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到window</code></p><h1 id="14，js事件循环机制中，使用得三种数据对象"><a href="#14，js事件循环机制中，使用得三种数据对象" class="headerlink" title="14，js事件循环机制中，使用得三种数据对象"></a>14，js事件循环机制中，使用得三种数据对象</h1><h2 id="栈：后进先出的数据结构"><a href="#栈：后进先出的数据结构" class="headerlink" title="栈：后进先出的数据结构"></a>栈：后进先出的数据结构</h2><h2 id="堆：树状的数据结构"><a href="#堆：树状的数据结构" class="headerlink" title="堆：树状的数据结构"></a>堆：树状的数据结构</h2><h2 id="队列：先进先出的数据结构"><a href="#队列：先进先出的数据结构" class="headerlink" title="队列：先进先出的数据结构"></a>队列：先进先出的数据结构</h2><h3 id="过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空"><a href="#过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空" class="headerlink" title="过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空"></a>过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空</h3><h3 id="如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环"><a href="#如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环" class="headerlink" title="如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环"></a>如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环</h3><h1 id="15，对rem和em经行说明"><a href="#15，对rem和em经行说明" class="headerlink" title="15，对rem和em经行说明"></a>15，对rem和em经行说明</h1><h2 id="em"><a href="#em" class="headerlink" title="em:"></a>em:</h2><p><code>子元素字体大小的em是相对于父元素字体大小</code><br><code>元素的width/height/hadding/margin用em的话是相对于该元素的font-size</code></p><h2 id="rem："><a href="#rem：" class="headerlink" title="rem："></a>rem：</h2><p><code>rem是相对长度单位，相对于根元素（即html元素）font-size</code><br><code>计算值的倍数的一个css单位</code><br>[参考] (<a href="https://zhuanlan.zhihu.com/p/94369298">https://zhuanlan.zhihu.com/p/94369298</a>)</p>]]></content>
      
      
      <categories>
          
          <category> -前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -前端面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="/2022/11/23/Ajax/"/>
      <url>/2022/11/23/Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="Aajx"><a href="#Aajx" class="headerlink" title="Aajx"></a>Aajx</h2>]]></content>
      
      
      <categories>
          
          <category> -Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级</title>
      <link href="/2022/11/23/js%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/11/23/js%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="js高级"><a href="#js高级" class="headerlink" title="js高级"></a>js高级</h2>]]></content>
      
      
      <categories>
          
          <category> -js内容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -jsa高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/2022/11/23/nodejs/"/>
      <url>/2022/11/23/nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2>]]></content>
      
      
      <categories>
          
          <category> -nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsapi</title>
      <link href="/2022/11/23/jsapi/"/>
      <url>/2022/11/23/jsapi/</url>
      
        <content type="html"><![CDATA[<h2 id="jsapi"><a href="#jsapi" class="headerlink" title="jsapi"></a>jsapi</h2>]]></content>
      
      
      <categories>
          
          <category> -js内容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -jsapi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础</title>
      <link href="/2022/11/23/js%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/23/js%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a><code>1. 变量</code></h1></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">● 由字母(A-Z a-z)、数字(<span class="number">0</span>-<span class="number">9</span>)、下划线(_)、美元符号( $ ) 组成</span><br><span class="line">● 严格区分大小写</span><br><span class="line">● 不能以数字开头</span><br><span class="line">● 不能是关键字、保留字</span><br><span class="line">● 变量名必须有意义</span><br><span class="line">● 推荐使用驼峰命名法</span><br></pre></td></tr></table></figure><hr><blockquote><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a><code>2. 数据类型</code></h1></blockquote><h2 id="基本数据类型（简单数据类型）："><a href="#基本数据类型（简单数据类型）：" class="headerlink" title="基本数据类型（简单数据类型）："></a>基本数据类型（简单数据类型）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number （数值型）    NaN也是数值型的一种  NaN和任何值做比较都是false</span><br><span class="line">String （字符串型）  带“ ”或者 ‘ ’都是字符串类型</span><br><span class="line">Boolean (布尔型)    只有两个值：ture（真）  false （假）</span><br><span class="line">Undefined (未定义)  已声明，却未赋值的，就是undefined</span><br><span class="line">null （空）         未定义的也未声明的</span><br><span class="line">Symbol             （es6新增，表示独一无二的值）</span><br></pre></td></tr></table></figure><h2 id="引用数据类型（复杂数据类型）："><a href="#引用数据类型（复杂数据类型）：" class="headerlink" title="引用数据类型（复杂数据类型）："></a>引用数据类型（复杂数据类型）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function    （函数）</span><br><span class="line">Object      （对象）</span><br><span class="line">Array       （数组）</span><br><span class="line">函数和数组是特殊的object类型（对象）</span><br></pre></td></tr></table></figure><h2 id="判断数据类型-type-of"><a href="#判断数据类型-type-of" class="headerlink" title="判断数据类型 (type of())"></a>判断数据类型 (type of())</h2><h3 id="可以判断的数据类型有："><a href="#可以判断的数据类型有：" class="headerlink" title="可以判断的数据类型有："></a>可以判断的数据类型有：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单数据类型：Number  String  Boolean  Undefined</span><br><span class="line">引用数据类型：Function</span><br></pre></td></tr></table></figure><h3 id="无法判断的数据类型："><a href="#无法判断的数据类型：" class="headerlink" title="无法判断的数据类型："></a>无法判断的数据类型：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单数据类型：null（判断结果为Object）</span><br><span class="line">引用数据类型：Object Array（判断结果为Object）</span><br></pre></td></tr></table></figure><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span> 和 <span class="title class_">Number</span>.<span class="property">isNaN</span> 函数的区别？</span><br><span class="line"></span><br><span class="line">函数 <span class="title class_">Number</span>.<span class="property">isNaN</span> 会首先判断传入参数是否为数字</span><br><span class="line">如果是数字再继续判断是否为 <span class="title class_">NaN</span>，不会进行数据类型的转换</span><br><span class="line">这种方法对于 <span class="title class_">NaN</span> 的判断更为准确</span><br><span class="line"></span><br><span class="line"> 对于字符串blue，本质上我们是想判断传入的参数是否为<span class="title class_">NaN</span></span><br><span class="line"> 但是用 <span class="built_in">isNaN</span> 函数，判断结果为真 </span><br><span class="line"> 所以说 <span class="built_in">isNaN</span>函数判断 <span class="title class_">NaN</span> 不够准确。</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><blockquote><h1 id="3-变量类型的转换"><a href="#3-变量类型的转换" class="headerlink" title="3. 变量类型的转换"></a><code>3. 变量类型的转换</code></h1></blockquote><h2 id="字符串型："><a href="#字符串型：" class="headerlink" title="字符串型："></a>字符串型：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量 + &#x27; &#x27;   （推荐转换方法）</span><br><span class="line">变量.tostring</span><br><span class="line">String（变量）</span><br></pre></td></tr></table></figure><h2 id="数值型："><a href="#数值型：" class="headerlink" title="数值型："></a>数值型：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">parseint（变量） ：得到整数</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseint</span>(<span class="string">&#x27;156a&#x27;</span>)); <span class="comment">//结果为156</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseint</span>(<span class="string">&#x27;156.a&#x27;</span>)); <span class="comment">//结果为156</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseint</span>(<span class="string">&#x27;A156.a&#x27;</span>)); <span class="comment">//结果为NaN</span></span><br><span class="line">总结：要转换的值如果有非数字不会转换非数字，开头如果就是非数字则返回<span class="title class_">NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>（变量） ：得到带浮点数的整数</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;1.15a&#x27;</span>)); <span class="comment">//结果为1.15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;a1.15a&#x27;</span>)); <span class="comment">//结果为NaN</span></span><br><span class="line">总结：可以得到浮点数 开头数字非数字返回<span class="title class_">NaN</span> ，要转换的值如果有非数字不会转换非数字</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>（变量）</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;156a&#x27;</span>)); <span class="comment">//结果为NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;156.1&#x27;</span>)); <span class="comment">//结果为156.1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;156&#x27;</span>)); <span class="comment">//结果为：156</span></span><br><span class="line">总结：可以得到整数和浮点数，只要带非数字就返回<span class="title class_">NaN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">变量  -  *  / %运算（隐式转换）</span><br><span class="line">注意：+ 不能隐式转换，+如果两边值不一样，默认为拼接</span><br><span class="line">但可以这样写来转换：</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">10</span>,b=<span class="string">&#x27;20&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c= +a + +b);</span><br><span class="line">c的结果为：<span class="number">30</span>  </span><br><span class="line"></span><br><span class="line">布尔型</span><br><span class="line"><span class="title class_">Boolean</span>（变量）</span><br><span class="line">转换 boolean 值为 <span class="literal">false</span> 的有： <span class="number">0</span>    ‘ ’    “ ”   <span class="literal">null</span>   <span class="literal">undefined</span>   <span class="title class_">NaN</span>，其他值转<span class="title class_">Boolean</span>都为ture</span><br></pre></td></tr></table></figure><hr><blockquote><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a><code>4. 运算符</code></h1></blockquote><h2 id="x2F"><a href="#x2F" class="headerlink" title="+ - * &#x2F; %"></a>+ - * &#x2F; %</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加减乘除 及取余</span><br><span class="line">求余% ：使用场景，用于判断某个数是否可以被整除，运算后的结果一般是余数</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将右边的值赋给左边 要求左边是一个变量 比如：</span><br><span class="line">a=10</span><br><span class="line">值可以是： 任意类型  或表达式或函数调用,如果是表达式要先运行完表达式才赋值</span><br><span class="line"></span><br><span class="line">+=  ：相当于：变量=变量+值 </span><br><span class="line"> 如：a+=1        (a=a+1)</span><br><span class="line">同样，还有-=  %= /= *=</span><br></pre></td></tr></table></figure><h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">++   --</span><br><span class="line">++或--在变量前面 比如 ++a/--a</span><br><span class="line">则表示先 自加/自减 再参与运算</span><br><span class="line"></span><br><span class="line">++或 -- 在变量后面 比如 a++/a--</span><br><span class="line">则表示先 参与运算 再进行自加/自减</span><br><span class="line">如果是单独写成一句，则两者没有区别 都是先使用再自加/自减</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;&gt;=&lt;=======!==!=</span><br><span class="line">==  比较两边的 值 是否相等，可能会进行自动的类型转换</span><br><span class="line">=== 比较两边的 值和类型 是否都相等，并不会转变类型</span><br><span class="line">!=比较两边的值是否相等，可能会进行自动的类型转换</span><br><span class="line">!== 比较两边的 值和类型 是否不相等 并不会转变类型</span><br><span class="line">== ===  !==三者的返回值都为Boolean</span><br><span class="line"></span><br><span class="line">注意：数值比较大小，字符串比较ASCII码是否相等，结果返回的都是Boolean值</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">与：&amp;&amp;</span><br><span class="line">或：||</span><br><span class="line">非：！</span><br><span class="line">结果都返回Boolean值</span><br><span class="line"></span><br><span class="line">条件拼接</span><br><span class="line">与：有一个条件不成立，那么就不成立，      全部成立才成立</span><br><span class="line">或：条件都不成立才不成立      有一个成立就成立</span><br><span class="line">非：取反  </span><br><span class="line">一般书写在流程语句中</span><br><span class="line"></span><br><span class="line">短路运算</span><br><span class="line">写在=号的右边&amp;&amp;如果第一个值为false就直接返回第一个值，否则返回第二个值</span><br><span class="line">||如果第一个值为ture就返回第一个值，否则返回第二个值</span><br></pre></td></tr></table></figure><hr><blockquote><h1 id="5-分支语句"><a href="#5-分支语句" class="headerlink" title="5.分支语句"></a><code>5.分支语句</code></h1></blockquote><h2 id="单分支："><a href="#单分支：" class="headerlink" title="单分支："></a>单分支：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(boolean值做条件)&#123;</span><br><span class="line">    <span class="comment">//条件成立要进行的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取<span class="title class_">Boolean</span>值的几种方式：</span><br><span class="line"><span class="number">1</span>，直接赋值ture或<span class="literal">false</span></span><br><span class="line"><span class="number">2</span>，关系运算符表达式--比较运算符</span><br><span class="line"><span class="number">3</span>，逻辑运算符--多条件</span><br><span class="line"><span class="number">4</span>，判断具体的变量值：在js中为<span class="literal">false</span>的值有：<span class="literal">undefined</span>  <span class="literal">null</span>  <span class="number">0</span>   <span class="string">&#x27; &#x27;</span>  <span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure><h2 id="双分支"><a href="#双分支" class="headerlink" title="双分支:"></a>双分支:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line"><span class="comment">//条件成立要进行的操作</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//条件不成立进行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多分支"><a href="#多分支" class="headerlink" title="多分支:"></a>多分支:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line"><span class="comment">//条件成立要进行的操作</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>（条件表达式）&#123;</span><br><span class="line"><span class="comment">//条件成立要进行的操作</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//上面条件都不成立要进行的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：（else if 可以无限套娃哦）</span></span><br></pre></td></tr></table></figure><h2 id="三元表达式（重点）"><a href="#三元表达式（重点）" class="headerlink" title="三元表达式（重点）:"></a>三元表达式（重点）:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：    </span></span><br><span class="line">条件表达式 ？条件成立后的操作：不成立之后的操作</span><br><span class="line"><span class="comment">//条件表达式满足返回第一个值，不满足返回第二个值</span></span><br><span class="line"><span class="comment">//代码示例： </span></span><br><span class="line"><span class="keyword">let</span> a=<span class="number">10.</span>b=<span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> demo= a &gt;= <span class="number">10</span> ? a : b</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo)</span><br><span class="line"><span class="comment">//demo结果为：10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注：可以写在模板字符串中，可以嵌套  </span></span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">Switch</span>语句</span><br><span class="line">    <span class="comment">// switch case 语句与 if else 语句的多分支结构类似，</span></span><br><span class="line">    <span class="comment">// 都可以根据不同的条件来执行不同的代码；</span></span><br><span class="line">    <span class="comment">// 但是与 if else 多分支结构相比，</span></span><br><span class="line">    <span class="comment">// switch case 语句更加简洁和紧凑，执行效率更高。</span></span><br><span class="line">    <span class="comment">// 下面是他的格式</span></span><br><span class="line">        <span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">value1</span>:</span><br><span class="line">         statements1 <span class="comment">// 当表达式的结果等于 value1 时，则执行该代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">value2</span>:</span><br><span class="line">         statements2 <span class="comment">// 当表达式的结果等于 value2 时，则执行该代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">valueN</span>:</span><br><span class="line">         statementsN <span class="comment">// 当表达式的结果等于 valueN 时，则执行该代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">         statements <span class="comment">// 如果没有与表达式相同的值，则执行该代码</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><blockquote><h1 id="6-循环"><a href="#6-循环" class="headerlink" title="6.循环"></a><code>6.循环</code></h1></blockquote><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)｛</span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">｝</span><br><span class="line"><span class="comment">// 如果条件满足，就执行循环体，如果不满足就结束循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环有三要素</span></span><br><span class="line"><span class="comment">// 初始值，条件 初始变量的的变化</span></span><br></pre></td></tr></table></figure><h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><p><code>其实还有一个do  while</code><br><code>do while 循环与 while 循环 非常相似</code><br><code>不同之处在于，do while 循环会先执行循环中的代码，然后再对条件表达式进行判断。</code><br><code>因此，无论条件表达式是真还是假，do while 循环都能至少执行一次</code><br><code>而 while 循环就不行了，如果条件表达式为假会直接退出 while 循环。</code></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">for</span>（初始值；循环条件；值的变化）&#123;</span><br><span class="line">    <span class="comment">// 要进行的操作（操作体）</span></span><br><span class="line">&#125;</span><br><span class="line">注意：分号不能少</span><br><span class="line"></span><br><span class="line">循环控制：<span class="keyword">continue</span>中止本次这一次循环操作，跳转到下一次循环操作</span><br><span class="line">         <span class="keyword">break</span>   中止当前循环--结束（跳出循环）</span><br><span class="line">                   可以进行循环嵌套</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><h1 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a><code>7.数组</code></h1><p><code>概念：可以存储多个值的一种数据类型，（是引用类型）</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">数组的创建：</span><br><span class="line"><span class="number">1.</span> 利用 <span class="keyword">new</span> 创建数组</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="number">2.</span> 利用数组字面量创建数组推荐</span><br><span class="line"><span class="keyword">const</span> arr = [ ];</span><br><span class="line">数组的元素获取我们可以通过下标来获取和操作</span><br><span class="line">语法为：数组[索引下标]</span><br><span class="line">注意：索引下标是从<span class="number">0</span>开始的</span><br><span class="line">数组遍历：  我们可以使用<span class="keyword">for</span>循环来做</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数组操作：</span><br><span class="line"></span><br><span class="line">新增：push：在数组的最后追加元素语法：数组.<span class="property">push</span>（新元素）</span><br><span class="line">    unshift：在数组的最前面插入一个新元素语法：数组.<span class="property">unshift</span>（新元素）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">移除最后一个元素： 数组.<span class="property">pop</span>（）</span><br><span class="line">删除第一个元素并返回第一个值：数组.<span class="property">shift</span>（）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除或插入或替换元素：数组.<span class="property">splice</span>（） 注意：这种方式会改变原始数组</span><br><span class="line">删除语法为：数组.<span class="property">splice</span>（起始位置，删除个数 ）如果没有传删除个数就删除起始位置后面的所有</span><br><span class="line">插入语法为：数组.<span class="property">splice</span>（起始位置，<span class="number">0</span>，插入的值）插入的值可以是多个</span><br><span class="line">替换语法为：数组.<span class="property">splice</span>（起始位置，要替换几个元素，替换的值）</span><br></pre></td></tr></table></figure><h3 id="拓展：-1"><a href="#拓展：-1" class="headerlink" title="拓展："></a>拓展：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">此外还有filter方法和map方法，这两个方法可以用来做遍历，我们一般用来做动态渲染</span><br><span class="line"></span><br><span class="line">filter () 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意： filter () 不会对空数组进行检测。 </span><br><span class="line">注意： filter () 不会改变原始数组。</span><br><span class="line"></span><br><span class="line"><span class="title function_">map</span>() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</span><br><span class="line"><span class="title function_">map</span>() 方法按照原始数组元素顺序依次处理元素。</span><br><span class="line">注意： <span class="title function_">map</span>() 不会对空数组进行检测。</span><br><span class="line">注意： <span class="title function_">map</span>() 不会改变原始数组</span><br></pre></td></tr></table></figure><h2 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h2><p><code> 并不是真正意义上的数组</code></p><ol><li><strong>具有数组的 length 属性</strong></li><li><strong>按照索引的方式进行存储的</strong></li><li><strong>它没有真正数组的一些方法 如pop()  push() 等等</strong></li></ol><hr><blockquote><h1 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a><code>8.函数</code></h1><p><code>作用：将代码块封装起来，方便复用，还可以简化代码的结构</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">声明定义：</span><br><span class="line"><span class="keyword">function</span> 函数名称(形式参数列表：不是必须)&#123;</span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line">调用：函数名称（实际参数列表：不是必须）</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="形参："><a href="#形参：" class="headerlink" title="形参："></a>形参：</h3><p><code>   可以定义多个，用逗号 ，隔开</code><br><code>    定义函数的时候，在（）写的就是形参</code><br><code>    声明定义的时候，形参只是参数占位</code><br><code>    在调用方法的时候，形参是一个变量</code><br><code>    相当于在方法中声明的局部变量，只有在方法内部可以使用，如果在方法外部使用，会报错</code></p><h3 id="实参："><a href="#实参：" class="headerlink" title="实参："></a>实参：</h3><p><code>    调用函数的时候，写在（）里面的就是实参</code><br><code>    实参是实际参数，是真正存在的值</code><br><code>    调用的时候，尽量让实参和形参：</code><br><code>    顺序对应：重点关注的问题，第一个实参为第一个形参赋值，依次累推</code><br><code>    数量对应：js本质是通过arguments来接收和处理参数，所以不传递或者传递更多参数语法是没有问题的</code><br><code>    类型对应：js是弱类型语言，不限制参数的类型</code></p><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数名称(实际参数列表：不是必须)</span><br><span class="line">调用函数的过程就是实参为形参赋值的过程</span><br><span class="line">只要在函数名称后面带有()就是调用函数，如果只有函数名称而没有（）就不是函数调用</span><br></pre></td></tr></table></figure><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法的本质功能是实现业务处理，但是不能对处理结果进行自定义的处理，一般是将结果返回</span><br><span class="line">return关键字可以实现返回值</span><br><span class="line">语法：return 一个变量</span><br><span class="line">注意：一个函数只能返回一个变量，如果有多个值需要返回，可以将多个值包装为对象，返回这一个对象，（也可以是包装为数组）</span><br><span class="line">return:可以中止函数，函数中运行到return后面的代码都不再执行</span><br><span class="line">一个函数中只有一个return可以被执行，先轮到谁就执行谁</span><br><span class="line"></span><br><span class="line">接收返回值</span><br><span class="line"></span><br><span class="line">调用的函数如果有返回值，可以定义一个变量用于接收这个函数的返回值</span><br><span class="line">函数返回了什么值，你就可以接收到什么值</span><br><span class="line">如果函数没有返回值，默认会返回undefined</span><br></pre></td></tr></table></figure><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p><code>只有函数才有 arguments 对象  而且是每个函数都内置好了这个arguments</code></p><hr><blockquote><h1 id="9-作用域"><a href="#9-作用域" class="headerlink" title="9.作用域"></a><code>9.作用域</code></h1><p>作用域一共有三种：</p></blockquote><ol><li><strong>全局作用域</strong></li><li><strong>函数作用域（局部）</strong></li><li><strong>块级作用域(es6新增)</strong><br><code>全局作用域：在script标签中声明的成员</code><br><code>函数作用域：局部作用域：在函数内部声明的成员</code><br><code>块级作用域：在｛｝中声明的成员</code></li></ol><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p><code>函数内部还可以创建函数，函数内部可以使用函数外部的成员，</code><br><code>当函数内部需要一个变量的时候，自己有就使用自己的，</code><br><code>如果没有就查找外部作用域，如果还没有， 再继续往外部找，</code><br><code>直到全局作用域，如果全局也没有，就报错</code></p><h2 id="拓展：-2"><a href="#拓展：-2" class="headerlink" title="拓展："></a>拓展：</h2><p><code>es6之前是没有块级作用域的，另外，es6之前我们声明变量是使用var，</code><br><code>let 和var的区别详解可点击此链接</code><br>[var和let的区别:] (‘<a href="https://blog.csdn.net/a1056244734/article/details/107150875&#39;">https://blog.csdn.net/a1056244734/article/details/107150875&#39;</a>)</p><hr><blockquote><h1 id="10-匿名函数"><a href="#10-匿名函数" class="headerlink" title="10.匿名函数"></a><code>10.匿名函数</code></h1><p><code>简单理解：没有名称的函数</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong><br><code>回调参数：将函数做为函数的参数，那么传递的函数参数就称为回调函数</code><br><code>简单理解：回调函数就是「把函数作为参数传递给另一个函数，然后通过另一个函数来调用它。</code></p><hr><blockquote><h1 id="11-自调用函数"><a href="#11-自调用函数" class="headerlink" title="11.自调用函数"></a><code>11.自调用函数</code></h1></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><code>第一种理解：自执行即自动执行，也就是大家平时所谓的立即执行函数。</code><br><code>第二种理解：即自执行函数是在函数内部执行函数本身，即我们平时常说的递归函数</code></p><h2 id="特点：自动执行，"><a href="#特点：自动执行，" class="headerlink" title="特点：自动执行，"></a>特点：自动执行，</h2><p><code>注意事项：function前面带</code>  <strong>;</strong> 号</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。</span><br><span class="line">执行递归函数将反复调用其自身，每调用一次就进入新的一层</span><br><span class="line">，当最内层的函数执行完毕后，再一层一层地由里到外退出。</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> -js内容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -js基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
