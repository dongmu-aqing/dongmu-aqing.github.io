<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试题</title>
      <link href="/2022/11/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/11/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1，闭包是什么"><a href="#1，闭包是什么" class="headerlink" title="1，闭包是什么"></a>1，闭包是什么</h1><p><code>两个函数（a,b）嵌套，内层函数b 调用了外层函数a中声明的变量，就叫闭包</code></p><h1 id="2，数组中的forEach和map："><a href="#2，数组中的forEach和map：" class="headerlink" title="2，数组中的forEach和map："></a>2，数组中的forEach和map：</h1><h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p><code> 都是遍历数组每一项，都有三个参数，都不改变原数组</code></p><h2 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h2><p><code> forEach是将一个数组中的每一项作为回调函数来处理，</code><br><code> map则返回一个新数组，数组中的元素是原数组的方法处理后的值</code></p><h1 id="3，浅拷贝和深拷贝"><a href="#3，浅拷贝和深拷贝" class="headerlink" title="3，浅拷贝和深拷贝"></a>3，浅拷贝和深拷贝</h1><h2 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h2><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><p><code>拷贝值，原来的和拷贝的互不影响</code></p><h3 id="引用数据类型："><a href="#引用数据类型：" class="headerlink" title="引用数据类型："></a>引用数据类型：</h3><p><code>拷贝地址，一改变原来的和拷贝的都改变，可以用展开运算符进行浅拷贝</code></p><h2 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h2><h3 id="引用数据类型：-1"><a href="#引用数据类型：-1" class="headerlink" title="引用数据类型："></a>引用数据类型：</h3><p><code>内存中开辟新地址，堆中的内容完整拷贝一份到新地址中，修改一个另一个并不受影响</code><br><code>可以用递归的方式进行深拷贝</code></p><h1 id="4，防抖和节流"><a href="#4，防抖和节流" class="headerlink" title="4，防抖和节流"></a>4，防抖和节流</h1><h2 id="防抖："><a href="#防抖：" class="headerlink" title="防抖："></a>防抖：</h2><p><code>连续触发事件，但是在设定的一段时间内只执行最后一次函数</code><br><code>记忆核心：从 新 开始</code><br><code>应用场景：文本编辑器和搜索框</code><br><code>代码实现思路主要靠定时器</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">   <span class="keyword">let</span> tid=<span class="literal">null</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;获取要操作的元素&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tid!==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(tid)</span><br><span class="line">        &#125;</span><br><span class="line">        tid=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;防抖&#x27;</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="节流："><a href="#节流：" class="headerlink" title="节流："></a>节流：</h2><p><code>连续触发事件但是在设定的一段时间内只执行一次函数</code></p><h3 id="记忆核心：-不要打断我"><a href="#记忆核心：-不要打断我" class="headerlink" title="记忆核心： 不要打断我"></a>记忆核心： <code>不要打断我</code></h3><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p><code>1，高频事件：快速点击，鼠标滑动，resize事件，scroll事件</code><br><code>2，下拉加载</code><br><code>3，视频播放记录时间等</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 代码示例</span></span><br><span class="line">    <span class="keyword">let</span> tid=<span class="literal">null</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;获取要操作的元素&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tid!==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        tid=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;防抖&#x27;</span>);</span><br><span class="line">            tid=<span class="literal">null</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//开发一般用lodash库，利用里面的debounce（防抖）和throttle（节流）来做</span></span><br></pre></td></tr></table></figure><h1 id="5，原型和原型链"><a href="#5，原型和原型链" class="headerlink" title="5，原型和原型链"></a>5，原型和原型链</h1><h2 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h2><p><code>所有的引用类型都有一个__proto__属性，所有的函数都有一个prototype属性</code><br><code>所有引用类型的__proto__都指向它构造函数的prototype</code></p><h2 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h2><p><code>当访问一个对象的某个属性的时候，先在对象本身查找，</code><br><code>如果没有，就去他的__proto__属性上找</code><br><code>如果还没有，就去__proto__所指向的构造函数的prototype找</code><br><code>还没有就去Object上找，最顶为null，这样的一个链式结构，就叫做原型链</code></p><h1 id="6，thie指向问题"><a href="#6，thie指向问题" class="headerlink" title="6，thie指向问题"></a>6，thie指向问题</h1><p><code>函数调用指向window</code><br><code>方法调用指向对象</code><br><code>构造函数调用指向它的实例对象</code><br><code>箭头函数则看外层有没有函数，有的话和外层函数指向一样，没有指向window</code></p><h1 id="7，call，bind，apply"><a href="#7，call，bind，apply" class="headerlink" title="7，call，bind，apply"></a>7，call，bind，apply</h1><p><code>都是用来改变this指向</code><br><code>第一个参数都是this的新指向</code><br><code>第二个及之后的参数call和bind是直接传入函数值，apply第二个参数则是数组或伪数组</code><br><code>bind方法不会直接执行函数，其他两个会主动执行函数</code></p><h1 id="8，回流和重绘的说明"><a href="#8，回流和重绘的说明" class="headerlink" title="8，回流和重绘的说明"></a>8，回流和重绘的说明</h1><h2 id="回流"><a href="#回流" class="headerlink" title="回流:"></a>回流:</h2><p><code>访问页面的时候浏览器会解析HTML代码并构建DOM树，</code><br><code>然后根据DOM节点进行几何布局生成渲染树，渲染树构建完成后，页面根据DOM节点进行几何布局</code><br><code>渲染树也根据设置的样式渲染这些节点，在这过程中我们删除节点，修改一个元素的宽高，页面布局会发生变化，DOM树就会重新构建</code><br><code>渲染树和DOM树紧密相连，渲染树也会重新渲染，这个过程称为回流或自动重排</code></p><h2 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h2><p><code>由于节点的几何属性发生改变或者由样式发生改变而不影响布局的，叫做重绘</code><br><code>个人简单理解：页面布局发生变化，会引起回流，修改元素样式不改变布局，会引起重绘</code><br><code>注意： 回流一定触发重绘，重绘不一定触发回流</code></p><h1 id="9，new关键字做了哪些事"><a href="#9，new关键字做了哪些事" class="headerlink" title="9，new关键字做了哪些事"></a>9，new关键字做了哪些事</h1><p><code>1，new一个空对象</code><br><code>2，将函数的this指向这个空对象</code><br><code>3，为新创建的对象添加__proto__,指向构造函数的原型对象</code><br><code>4，如果函数返回对象，就把这个对象作为返回值，如果没有返回对象就返回this</code></p><h1 id="10，async和await的理解"><a href="#10，async和await的理解" class="headerlink" title="10，async和await的理解"></a>10，async和await的理解</h1><p><code>1，是异步代码的新方式</code><br><code>2，基于promise实现</code><br><code>3，使异步代码更像同步代码</code><br><code>4，await只能在async中使用，不能在普通函数中使用，成对出现</code><br><code>5，默认返回一个promise实例，不能改变</code><br><code>6，await下面的代码是异步，后面的代码是同步的</code></p><h1 id="11-如何理解promise？"><a href="#11-如何理解promise？" class="headerlink" title="11,如何理解promise？"></a>11,如何理解promise？</h1><p><code>1，异步编程的解决方案，用来解决回调地狱</code><br><code>2,有三种状态：pending（进行中），fufilled（已成功），rejected（已失败）</code><br><code>3，基本用法是new Promise（）传入一个函数，函数里面有两个参数，一个是resolve成功的回调，一个是reject失败的回调</code><br><code>new出来的有三个方法：参数都是一个数组</code><br><code>all:如果数组里面所有的promise都是resolve就进入then方法，有一个reject就进入catch</code><br><code>allSettled：在then方法中返回所有的promise数组结果，不管成功的还是失败的</code><br><code>rece：数组中的promise哪个先返回结果就使用哪个结果</code></p><h1 id="12-对作用域进行说明"><a href="#12-对作用域进行说明" class="headerlink" title="12,对作用域进行说明"></a>12,对作用域进行说明</h1><h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p><code>指变量的有效范围</code></p><h3 id="有三种作用域-分别是："><a href="#有三种作用域-分别是：" class="headerlink" title="有三种作用域 分别是："></a>有三种作用域 分别是：</h3><h2 id="全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到"><a href="#全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到" class="headerlink" title="全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到"></a>全局作用域：书写在JavaScript标签的变量，任何内部函数都能访问到</h2><h2 id="局部作用域（函数作用域）：-在函数内可以访问，函数外部无法访问"><a href="#局部作用域（函数作用域）：-在函数内可以访问，函数外部无法访问" class="headerlink" title="局部作用域（函数作用域）： 在函数内可以访问，函数外部无法访问"></a>局部作用域（函数作用域）： 在函数内可以访问，函数外部无法访问</h2><h2 id="块级作用域（es6新增）：-凡是代码块就可以划分变量的作用域"><a href="#块级作用域（es6新增）：-凡是代码块就可以划分变量的作用域" class="headerlink" title="块级作用域（es6新增）：  凡是代码块就可以划分变量的作用域"></a>块级作用域（es6新增）：  凡是代码块就可以划分变量的作用域</h2><h1 id="13，事件对象和事件委托"><a href="#13，事件对象和事件委托" class="headerlink" title="13，事件对象和事件委托"></a>13，事件对象和事件委托</h1><h2 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h2><p><code>一个函数或者方法都会带有一个事件对象参数</code><br><code>事件对象.target是获取最先触发的元素</code><br><code>事件对象有两种公共的方法：</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="title function_">preventDefault</span>() <span class="comment">//阻止默认行为</span></span><br><span class="line">e.<span class="title function_">stopPropagation</span>() <span class="comment">//阻止冒泡</span></span><br></pre></td></tr></table></figure><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><code>可以把事件处理器添加到一个上级元素上，避免把事件处理器添加到多个子元素上，提高性能</code><br><code>还可以预测未来，动态添加的元素仍然可以触发该事件</code><br><code>主要依靠的就是事件冒泡，也就是当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到window</code></p><h1 id="14，js事件循环机制中，使用得三种数据对象"><a href="#14，js事件循环机制中，使用得三种数据对象" class="headerlink" title="14，js事件循环机制中，使用得三种数据对象"></a>14，js事件循环机制中，使用得三种数据对象</h1><h2 id="栈：后进先出的数据结构"><a href="#栈：后进先出的数据结构" class="headerlink" title="栈：后进先出的数据结构"></a>栈：后进先出的数据结构</h2><h2 id="堆：树状的数据结构"><a href="#堆：树状的数据结构" class="headerlink" title="堆：树状的数据结构"></a>堆：树状的数据结构</h2><h2 id="队列：先进先出的数据结构"><a href="#队列：先进先出的数据结构" class="headerlink" title="队列：先进先出的数据结构"></a>队列：先进先出的数据结构</h2><h3 id="过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空"><a href="#过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空" class="headerlink" title="过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空"></a>过程：当所有的同步任务都在主线程上执行就形成一个执行栈，当主线程的执行栈为空时，检查事件队列是否为空</h3><h3 id="如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环"><a href="#如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环" class="headerlink" title="如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环"></a>如果为空则继续检查，如果不为空则取出队列任务的首部，加入执行栈，执行任务，如此循环称为事件循环</h3><h1 id="15，对rem和em经行说明"><a href="#15，对rem和em经行说明" class="headerlink" title="15，对rem和em经行说明"></a>15，对rem和em经行说明</h1><h2 id="em"><a href="#em" class="headerlink" title="em:"></a>em:</h2><p><code>子元素字体大小的em是相对于父元素字体大小</code><br><code>元素的width/height/hadding/margin用em的话是相对于该元素的font-size</code></p><h2 id="rem："><a href="#rem：" class="headerlink" title="rem："></a>rem：</h2><p><code>rem是相对长度单位，相对于根元素（即html元素）font-size</code><br><code>计算值的倍数的一个css单位</code><br>[参考] (<a href="https://zhuanlan.zhihu.com/p/94369298">https://zhuanlan.zhihu.com/p/94369298</a>)</p>]]></content>
      
      
      <categories>
          
          <category> -前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -前端面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="/2022/11/23/Ajax/"/>
      <url>/2022/11/23/Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="Aajx"><a href="#Aajx" class="headerlink" title="Aajx"></a>Aajx</h2>]]></content>
      
      
      <categories>
          
          <category> -Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsapi</title>
      <link href="/2022/11/23/jsapi/"/>
      <url>/2022/11/23/jsapi/</url>
      
        <content type="html"><![CDATA[<h2 id="jsapi"><a href="#jsapi" class="headerlink" title="jsapi"></a>jsapi</h2>]]></content>
      
      
      <categories>
          
          <category> -js内容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -jsapi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级</title>
      <link href="/2022/11/23/js%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/11/23/js%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="js高级"><a href="#js高级" class="headerlink" title="js高级"></a>js高级</h2>]]></content>
      
      
      <categories>
          
          <category> -js内容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -jsa高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/2022/11/23/nodejs/"/>
      <url>/2022/11/23/nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2>]]></content>
      
      
      <categories>
          
          <category> -nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础</title>
      <link href="/2022/11/23/js%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/23/js%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a><code>变量</code></h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">● 由字母(A-Z a-z)、数字(<span class="number">0</span>-<span class="number">9</span>)、下划线(_)、美元符号( $ ) 组成</span><br><span class="line">● 严格区分大小写</span><br><span class="line">● 不能以数字开头</span><br><span class="line">● 不能是关键字、保留字</span><br><span class="line">● 变量名必须有意义</span><br><span class="line">● 推荐使用驼峰命名法</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><code>数据类型</code></h1><h2 id="基本数据类型（简单数据类型）："><a href="#基本数据类型（简单数据类型）：" class="headerlink" title="基本数据类型（简单数据类型）："></a>基本数据类型（简单数据类型）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number （数值型）    NaN也是数值型的一种  NaN和任何值做比较都是false</span><br><span class="line">String （字符串型）  带“ ”或者 ‘ ’都是字符串类型</span><br><span class="line">Boolean (布尔型)    只有两个值：ture（真）  false （假）</span><br><span class="line">Undefined (未定义)  已声明，却未赋值的，就是undefined</span><br><span class="line">null （空）         未定义的也未声明的</span><br><span class="line">Symbol             （es6新增，表示独一无二的值）</span><br></pre></td></tr></table></figure><h2 id="引用数据类型（复杂数据类型）："><a href="#引用数据类型（复杂数据类型）：" class="headerlink" title="引用数据类型（复杂数据类型）："></a>引用数据类型（复杂数据类型）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function    （函数）</span><br><span class="line">Object      （对象）</span><br><span class="line">Array       （数组）</span><br><span class="line">函数和数组是特殊的object类型（对象）</span><br></pre></td></tr></table></figure><h2 id="判断数据类型-type-of"><a href="#判断数据类型-type-of" class="headerlink" title="判断数据类型 (type of())"></a>判断数据类型 (type of())</h2><h3 id="可以判断的数据类型有："><a href="#可以判断的数据类型有：" class="headerlink" title="可以判断的数据类型有："></a>可以判断的数据类型有：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单数据类型：Number  String  Boolean  Undefined</span><br><span class="line">引用数据类型：Function</span><br></pre></td></tr></table></figure><h3 id="无法判断的数据类型："><a href="#无法判断的数据类型：" class="headerlink" title="无法判断的数据类型："></a>无法判断的数据类型：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单数据类型：null（判断结果为Object）</span><br><span class="line">引用数据类型：Object Array（判断结果为Object）</span><br></pre></td></tr></table></figure><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span> 和 <span class="title class_">Number</span>.<span class="property">isNaN</span> 函数的区别？</span><br><span class="line"></span><br><span class="line">函数 <span class="title class_">Number</span>.<span class="property">isNaN</span> 会首先判断传入参数是否为数字</span><br><span class="line">如果是数字再继续判断是否为 <span class="title class_">NaN</span>，不会进行数据类型的转换</span><br><span class="line">这种方法对于 <span class="title class_">NaN</span> 的判断更为准确</span><br><span class="line"></span><br><span class="line"> 对于字符串blue，本质上我们是想判断传入的参数是否为<span class="title class_">NaN</span></span><br><span class="line"> 但是用 <span class="built_in">isNaN</span> 函数，判断结果为真 </span><br><span class="line"> 所以说 <span class="built_in">isNaN</span>函数判断 <span class="title class_">NaN</span> 不够准确。</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h1 id="变量类型的转换"><a href="#变量类型的转换" class="headerlink" title="变量类型的转换"></a><code>变量类型的转换</code></h1><h2 id="字符串型："><a href="#字符串型：" class="headerlink" title="字符串型："></a>字符串型：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量 + &#x27; &#x27;   （推荐转换方法）</span><br><span class="line">变量.tostring</span><br><span class="line">String（变量）</span><br></pre></td></tr></table></figure><h2 id="数值型："><a href="#数值型：" class="headerlink" title="数值型："></a>数值型：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">parseint（变量） ：得到整数</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseint</span>(<span class="string">&#x27;156a&#x27;</span>)); <span class="comment">//结果为156</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseint</span>(<span class="string">&#x27;156.a&#x27;</span>)); <span class="comment">//结果为156</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">parseint</span>(<span class="string">&#x27;A156.a&#x27;</span>)); <span class="comment">//结果为NaN</span></span><br><span class="line">总结：要转换的值如果有非数字不会转换非数字，开头如果就是非数字则返回<span class="title class_">NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>（变量） ：得到带浮点数的整数</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;1.15a&#x27;</span>)); <span class="comment">//结果为1.15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;a1.15a&#x27;</span>)); <span class="comment">//结果为NaN</span></span><br><span class="line">总结：可以得到浮点数 开头数字非数字返回<span class="title class_">NaN</span> ，要转换的值如果有非数字不会转换非数字</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>（变量）</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;156a&#x27;</span>)); <span class="comment">//结果为NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;156.1&#x27;</span>)); <span class="comment">//结果为156.1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;156&#x27;</span>)); <span class="comment">//结果为：156</span></span><br><span class="line">总结：可以得到整数和浮点数，只要带非数字就返回<span class="title class_">NaN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">变量  -  *  / %运算（隐式转换）</span><br><span class="line">注意：+ 不能隐式转换，+如果两边值不一样，默认为拼接</span><br><span class="line">但可以这样写来转换：</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">10</span>,b=<span class="string">&#x27;20&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c= +a + +b);</span><br><span class="line">c的结果为：<span class="number">30</span>  </span><br><span class="line"></span><br><span class="line">布尔型</span><br><span class="line"><span class="title class_">Boolean</span>（变量）</span><br><span class="line">转换 boolean 值为 <span class="literal">false</span> 的有： <span class="number">0</span>    ‘ ’    “ ”   <span class="literal">null</span>   <span class="literal">undefined</span>   <span class="title class_">NaN</span>，其他值转<span class="title class_">Boolean</span>都为ture</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><code>运算符</code></h1><h2 id="x2F"><a href="#x2F" class="headerlink" title="+ - * &#x2F; %"></a>+ - * &#x2F; %</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加减乘除 及取余</span><br><span class="line">求余% ：使用场景，用于判断某个数是否可以被整除，运算后的结果一般是余数</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将右边的值赋给左边 要求左边是一个变量 比如：</span><br><span class="line">a=10</span><br><span class="line">值可以是： 任意类型  或表达式或函数调用,如果是表达式要先运行完表达式才赋值</span><br><span class="line"></span><br><span class="line">+=  ：相当于：变量=变量+值 </span><br><span class="line"> 如：a+=1        (a=a+1)</span><br><span class="line">同样，还有-=  %= /= *=</span><br></pre></td></tr></table></figure><h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">++   --</span><br><span class="line">++或--在变量前面 比如 ++a/--a</span><br><span class="line">则表示先 自加/自减 再参与运算</span><br><span class="line"></span><br><span class="line">++或 -- 在变量后面 比如 a++/a--</span><br><span class="line">则表示先 参与运算 再进行自加/自减</span><br><span class="line">如果是单独写成一句，则两者没有区别 都是先使用再自加/自减</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;&gt;=&lt;=======!==!=</span><br><span class="line">==  比较两边的 值 是否相等，可能会进行自动的类型转换</span><br><span class="line">=== 比较两边的 值和类型 是否都相等，并不会转变类型</span><br><span class="line">!=比较两边的值是否相等，可能会进行自动的类型转换</span><br><span class="line">!== 比较两边的 值和类型 是否不相等 并不会转变类型</span><br><span class="line">== ===  !==三者的返回值都为Boolean</span><br><span class="line"></span><br><span class="line">注意：数值比较大小，字符串比较ASCII码是否相等，结果返回的都是Boolean值</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">与：&amp;&amp;</span><br><span class="line">或：||</span><br><span class="line">非：！</span><br><span class="line">结果都返回Boolean值</span><br><span class="line"></span><br><span class="line">条件拼接</span><br><span class="line">与：有一个条件不成立，那么就不成立，      全部成立才成立</span><br><span class="line">或：条件都不成立才不成立      有一个成立就成立</span><br><span class="line">非：取反  </span><br><span class="line">一般书写在流程语句中</span><br><span class="line"></span><br><span class="line">短路运算</span><br><span class="line">写在=号的右边&amp;&amp;如果第一个值为false就直接返回第一个值，否则返回第二个值</span><br><span class="line">||如果第一个值为ture就返回第一个值，否则返回第二个值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -js内容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -js基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
